import uuid from 'uuid'
import moment from 'moment'
import axios from 'axios'
// import {postsByCategory} from '../reducers'
// import fetch from 'isomorphic-fetch'

//define some constants
export const SELECT_CATEGORY = 'SELECT_CATEGORY'
export const REFRESH_CATEGORY = 'REFRESH_CATEGORY'
export const REQUEST_POSTS = 'REQUEST_POSTS'
export const RECEIVED_POSTS = 'RECEIVED_POSTS'
export const RECEIVED_ERROR = 'RECEIVED_ERROR'

export const ADD_POST = 'ADD_POST'
export const REMOVE_POST = 'REMOVE_POST'
export const EDIT_POST = 'EDIT_POST'
export const SORT_BY_DATE = 'SORT_BY_DATE'
export const SORT_BY_VOTESCORE = 'SORT_BY_VOTESCORE'
export const INCREMENT_VOTESCORE = 'INCREMENT_VOTESCORE'
export const SET_TEXT_FILTER = 'SET_TEXT_FILTER'
//
export const CREATE_POST = 'CREATE_POST'

//sample state shape of my data - the comments are included
const demodata = {
  selectedCategory: 'react',
  postsByCategory: {
    react: {
      isFetching: true,
      didRefresh: false,
      posts: [
        {id: 58676, title: 'React 16 released.', body: 'It is much faster now.',author:'Michelangelo',timestamp: 1468166872655,voteScore: 10,deleted: false},
      ],
      comments: [
        {id: 90990, parentId:58676, body:'New comment.',timestamp:1468166872690,author:'Joseph', voteScore:3, deleted: false, parentDeleted:false}
      ]
    },
    redux: {
      isFetching: false,
      didRefresh: false,
      posts: [
        {id: 34234, title: 'Structuring reducers concept.', body: 'actions creators text',author:'Gabriel',timestamp: 1468166872655,voteScore: 1,deleted: false},
        {id: 92828, title: 'I use combineReducers because ...', body: 'actions creators text',author:'Dani',timestamp: 1468166888655,voteScore: 3,deleted: false}
      ],
      comments: [
        {id: 24244, parentId:34234, body:'Made this comment today.',timestamp:1468166872755,author:'Raphael', voteScore:3, deleted: false, parentDeleted:false}
      ]
    }
  }
}

//define actions generated by the user
export const selectCategory = (category) => {
  return {
    type: SELECT_CATEGORY,
    category
  }
}
//implement this later  if necessary
export const refreshCategory = (category) => {
  return {
    type: REFRESH_CATEGORY,
    category
  }
}

//actions to fetch from server
export const requestPosts = (category) => {
  return {
    type: REQUEST_POSTS,
    category
  }
}

export const receivedPosts = (category, json, state) => {
  const selectedCategory = state.selectedCategory
  const posts = state.postsByCategory[category].items

  return {
    type: RECEIVED_POSTS,
    category,
    posts: posts ? posts.concat(json.data.children.map(child => child.data)) : json.data.children.map(child => child.data),
    receivedAt: Date.now()
  }
}

//action creators
// export const fetchPostSuccess = (posts) => {
//   return {
//     type:FETCH_POSTS,
//     posts
//   }
// }
//fetch posts action creator
// export const fetchPosts = (category) => {
//   console.log('fetching category', category);
//   return (dispatch) => {
//     dispatch(requestPosts(category))
//     return fetch('http://localhost:3001/posts', { headers: { 'Authorization': '123react' }})
//       .then(response => response.json())
//       .then(json => dispatch(receivedPosts(category, json)))
//   }
// }

export const receiveError = (json) => {
  return {
    type:RECEIVED_ERROR,
    json
  }
}

const url = 'http://localhost:3001/posts'

export const fetchPosts = (category) => {
	return (dispatch, getState) => {
		dispatch(requestPosts(category));
		return axios({
      url: url,
			category: category,
			method: 'get',
			responseType: 'json',
      headers: { 'Authorization': '123react' }
		})
			.then((response) => {
				dispatch(receivedPosts(category, response.data, getState()));
			})
			.catch((response) => {
				dispatch(receiveError(response.data));

			})
	}
}

const shouldFetchPosts = (state, category) => {
  const posts = state.postsByCategory[category];
  if (!posts) {
    return true;
  } else if (posts.isFetching){
    return false;
  } else {
    return posts.didInvalidate;
  }
}

export const fetchPostsIfNeeded = (category) => {
  return (dispatch, getState) => {
    if (shouldFetchPosts(getState(), category)) {
      return dispatch(fetchPosts(category))
    }
  }
}

//add proxy rule to package.json
/*
"proxy": {
  "/posts": {
    "target": "http://localhost:3001"
  }
},
*/

// export const fetchPosts = (category) => {
//   return (dispatch) => {
//     dispatch(requestPosts(category))
//     axios
//       .get('http://localhost:3001/posts',{ headers: { 'Authorization': '123react' }})
//       .then(response => dispatch(receivedPosts(response.data)))
//   }
// }


//destructuring values coming in from user, then attach them to the post object
export const addPost = ({title='',body='',author='',category='',timestamp= Date.now(), voteScore=1, deleted=false} = {}) => ({
  type: ADD_POST,
  post: {
    id: uuid(),
    title,
    body,
    timestamp,
    author,
    category,
    voteScore,
    deleted
  }
})

export const removePost = ({id} = {}) => ({
  type: REMOVE_POST,
  id
})

export const editPost = (id, updates) => ({
  type: EDIT_POST,
  id,
  updates
})

export const sortByDate = () => ({
  type: 'SORT_BY_DATE'
})
export const sortByVoteScore = () => ({
  type: 'SORT_BY_VOTESCORE'
})

/* NOTE: create the case for the INCREMENT_VOTESCORE in the incrementVoteScore action creator */
//
